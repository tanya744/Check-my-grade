# -*- coding: utf-8 -*-
"""CheckMyGrade.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H4pGlmxY_lIAUXclJ9FoelX9wmyO5EA7
"""

# === CELL 1: Create the main CheckMyGrade application file ===
code = r'''
"""
CheckMyGrade - Console-based OOP application with CSV storage.
Implements Student, Course, Professor, Grades, and LoginUser with:
- add/delete/modify/search/sort
- timing for search/sort
- average/median calculations by course
- reversible "encryption" demo for password storage (illustrative only)
"""

from __future__ import annotations

import csv
from dataclasses import dataclass, asdict
from pathlib import Path
from typing import List, Optional, Tuple, Callable, Any, Dict
from statistics import median
import base64
import time

# --- personalization (shows who ran it + nicer timing) ---
RUN_BY = "TPS"                  # <--- put your initials/name here
def ms(sec: float) -> str:      # show timings in milliseconds
    return f"{sec*1000:.3f} ms"


# ------------------------- Utility: "Encryption" (illustrative) -------------------------

def _xor_bytes(data: bytes, key: bytes) -> bytes:
    """Simple XOR for demonstration; NOT secure. Assignment requires encrypt+decrypt."""
    if not key:
        raise ValueError("Key must not be empty")
    return bytes(b ^ key[i % len(key)] for i, b in enumerate(data))


def encrypt_password(plain: str, key: str) -> str:
    raw = plain.encode("utf-8")
    xored = _xor_bytes(raw, key.encode("utf-8"))
    return base64.urlsafe_b64encode(xored).decode("ascii")


def decrypt_password(token: str, key: str) -> str:
    xored = base64.urlsafe_b64decode(token.encode("ascii"))
    raw = _xor_bytes(xored, key.encode("utf-8"))
    return raw.decode("utf-8")


# ------------------------- Data Models -------------------------

@dataclass
class Student:
    email: str
    first_name: str
    last_name: str
    course_id: str
    grade: str
    marks: float

    @property
    def name(self) -> str:
        return f"{self.first_name} {self.last_name}"


@dataclass
class Course:
    course_id: str
    course_name: str
    description: str = ""


@dataclass
class Professor:
    email: str
    name: str
    rank: str
    course_id: str


@dataclass
class GradeRange:
    grade_id: str
    grade: str
    marks_range: str  # e.g., "90-100"


@dataclass
class LoginUser:
    email: str
    password_encrypted: str
    role: str = "student"  # or "professor"


# ------------------------- Persistence Layer -------------------------

class CsvStore:
    """Generic CSV store for records with headers in a given order."""
    def __init__(self, path: Path, headers: List[str]):
        self.path = path
        self.headers = headers
        self.path.parent.mkdir(parents=True, exist_ok=True)
        if not self.path.exists():
            with self.path.open("w", newline="", encoding="utf-8") as f:
                writer = csv.DictWriter(f, fieldnames=self.headers)
                writer.writeheader()

    def read_all(self) -> List[dict]:
        with self.path.open("r", newline="", encoding="utf-8") as f:
            reader = csv.DictReader(f)
            return list(reader)

    def write_all(self, rows: List[dict]) -> None:
        with self.path.open("w", newline="", encoding="utf-8") as f:
            writer = csv.DictWriter(f, fieldnames=self.headers)
            writer.writeheader()
            for r in rows:
                writer.writerow(r)

    def append(self, row: dict) -> None:
        if not self.path.exists():
            self.write_all([])
        with self.path.open("a", newline="", encoding="utf-8") as f:
            writer = csv.DictWriter(f, fieldnames=self.headers)
            writer.writerow(row)


# ------------------------- Managers -------------------------

class StudentManager:
    def __init__(self, csv_path: Path):
        self.store = CsvStore(csv_path, ["email", "first_name", "last_name", "course_id", "grade", "marks"])

    def add(self, s: Student) -> None:
        rows = self.store.read_all()
        if any(r["email"] == s.email for r in rows):
            raise ValueError("Student email must be unique")
        self.store.append({
            "email": s.email,
            "first_name": s.first_name,
            "last_name": s.last_name,
            "course_id": s.course_id,
            "grade": s.grade,
            "marks": f"{float(s.marks):.2f}",
        })

    def list(self) -> List[Student]:
        return [Student(r["email"], r["first_name"], r["last_name"],
                        r["course_id"], r["grade"], float(r["marks"])) for r in self.store.read_all()]

    def delete(self, email: str) -> bool:
        rows = self.store.read_all()
        new_rows = [r for r in rows if r["email"] != email]
        self.store.write_all(new_rows)
        return len(new_rows) != len(rows)

    def update(self, email: str, **changes) -> bool:
        rows = self.store.read_all()
        updated = False
        for r in rows:
            if r["email"] == email:
                for k, v in changes.items():
                    if k in r:
                        r[k] = str(v)
                updated = True
        if updated:
            self.store.write_all(rows)
        return updated

    def search(self, predicate: Callable[[Student], bool]) -> Tuple[List[Student], float]:
        start = time.perf_counter()
        result = [s for s in self.list() if predicate(s)]
        elapsed = time.perf_counter() - start
        return result, elapsed

    def sort(self, key: Callable[[Student], Any], reverse: bool=False) -> Tuple[List[Student], float]:
        students = self.list()
        start = time.perf_counter()
        sorted_students = sorted(students, key=key, reverse=reverse)
        elapsed = time.perf_counter() - start
        return sorted_students, elapsed

    def stats_by_course(self, course_id: str) -> Dict[str, Any]:
        students = [s for s in self.list() if s.course_id == course_id]
        marks = [s.marks for s in students]
        if not marks:
            return {"count": 0, "average": None, "median": None}
        avg = sum(marks) / len(marks)
        med = median(marks)
        return {"count": len(marks), "average": round(avg, 2), "median": round(med, 2)}


class CourseManager:
    def __init__(self, csv_path: Path):
        self.store = CsvStore(csv_path, ["course_id", "course_name", "description"])

    def add(self, c: Course) -> None:
        rows = self.store.read_all()
        if any(r["course_id"] == c.course_id for r in rows):
            raise ValueError("course_id must be unique")
        self.store.append(asdict(c))

    def list(self) -> List[Course]:
        return [Course(**r) for r in self.store.read_all()]

    def delete(self, course_id: str) -> bool:
        rows = self.store.read_all()
        new_rows = [r for r in rows if r["course_id"] != course_id]
        self.store.write_all(new_rows)
        return len(new_rows) != len(rows)

    def update(self, course_id: str, **changes) -> bool:
        rows = self.store.read_all()
        updated = False
        for r in rows:
            if r["course_id"] == course_id:
                for k, v in changes.items():
                    if k in r:
                        r[k] = str(v)
                updated = True
        if updated:
            self.store.write_all(rows)
        return updated


class ProfessorManager:
    def __init__(self, csv_path: Path):
        self.store = CsvStore(csv_path, ["email", "name", "rank", "course_id"])

    def add(self, p: Professor) -> None:
        rows = self.store.read_all()
        if any(r["email"] == p.email for r in rows):
            raise ValueError("Professor email must be unique")
        self.store.append(asdict(p))

    def list(self) -> List[Professor]:
        return [Professor(**r) for r in self.store.read_all()]

    def delete(self, email: str) -> bool:
        rows = self.store.read_all()
        new_rows = [r for r in rows if r["email"] != email]
        self.store.write_all(new_rows)
        return len(new_rows) != len(rows)

    def update(self, email: str, **changes) -> bool:
        rows = self.store.read_all()
        updated = False
        for r in rows:
            if r["email"] == email:
                for k, v in changes.items():
                    if k in r:
                        r[k] = str(v)
                updated = True
        if updated:
            self.store.write_all(rows)
        return updated


class GradeManager:
    def __init__(self, csv_path: Path):
        self.store = CsvStore(csv_path, ["grade_id", "grade", "marks_range"])

    def add(self, g: GradeRange) -> None:
        rows = self.store.read_all()
        if any(r["grade_id"] == g.grade_id for r in rows):
            raise ValueError("grade_id must be unique")
        self.store.append(asdict(g))

    def list(self) -> List[GradeRange]:
        return [GradeRange(**r) for r in self.store.read_all()]

    def delete(self, grade_id: str) -> bool:
        rows = self.store.read_all()
        new_rows = [r for r in rows if r["grade_id"] != grade_id]
        self.store.write_all(new_rows)
        return len(new_rows) != len(rows)

    def update(self, grade_id: str, **changes) -> bool:
        rows = self.store.read_all()
        updated = False
        for r in rows:
            if r["grade_id"] == grade_id:
                for k, v in changes.items():
                    if k in r:
                        r[k] = str(v)
                updated = True
        if updated:
            self.store.write_all(rows)
        return updated


class AuthManager:
    def __init__(self, csv_path: Path, key: str):
        self.key = key
        self.store = CsvStore(csv_path, ["email", "password", "role"])

    def register(self, email: str, password: str, role: str) -> None:
        rows = self.store.read_all()
        if any(r["email"] == email for r in rows):
            raise ValueError("User already exists")
        encrypted = encrypt_password(password, key=self.key)
        self.store.append({"email": email, "password": encrypted, "role": role})

    def login(self, email: str, password: str) -> bool:
        rows = self.store.read_all()
        for r in rows:
            if r["email"] == email:
                try:
                    plain = decrypt_password(r["password"], key=self.key)
                except Exception:
                    return False
                return plain == password
        return False

    def change_password(self, email: str, old_password: str, new_password: str) -> bool:
        rows = self.store.read_all()
        for r in rows:
            if r["email"] == email:
                plain = decrypt_password(r["password"], key=self.key)
                if plain != old_password:
                    return False
                r["password"] = encrypt_password(new_password, key=self.key)
                self.store.write_all(rows)
                return True
        return False


# ------------------------- Simple Console UI -------------------------

class App:
    def __init__(self, base_dir: Path, key: str = "Tanya#2025!"):
        # personalized filenames
        self.students = StudentManager(base_dir / "students_db.csv")
        self.courses = CourseManager(base_dir / "courses_db.csv")
        self.professors = ProfessorManager(base_dir / "professors_db.csv")
        self.grades = GradeManager(base_dir / "grades_db.csv")
        self.auth = AuthManager(base_dir / "accounts_db.csv", key=key)

    def demo_populate(self) -> None:
        if not any(c.course_id == "DATA200" for c in self.courses.list()):
            self.courses.add(Course("DATA200", "Data Science", "Intro to DS and Python"))
        if not any(p.email == "micheal@mycsu.edu" for p in self.professors.list()):
            self.professors.add(Professor("micheal@mycsu.edu", "Micheal John", "Senior Professor", "DATA200"))

        existing = {s.email for s in self.students.list()}
        sample = [
            Student("tanya@mycsu.edu",   "Tanya",  "Shah",   "DATA200", "A", 96),
            Student("vedant@mycsu.edu",  "Vedant", "Vartak", "DATA200", "B", 84),
            Student("hiya@mycsu.edu",    "Hiya",   "Shah",   "DATA200", "A", 92),
        ]
        for s in sample:
            if s.email not in existing:
                self.students.add(s)

    def search_by_email(self, email: str) -> Tuple[List[Student], float]:
        return self.students.search(lambda s: s.email == email)

    def sort_by_marks(self, reverse: bool=False) -> Tuple[List[Student], float]:
        return self.students.sort(lambda s: s.marks, reverse=reverse)

    def sort_by_name(self, reverse: bool=False) -> Tuple[List[Student], float]:
        return self.students.sort(lambda s: s.name.lower(), reverse=reverse)

    def course_stats(self, course_id: str):
        return self.students.stats_by_course(course_id)


if __name__ == "__main__":
    base = Path("./data")
    base.mkdir(exist_ok=True, parents=True)
    app = App(base)
    app.demo_populate()

    # search for YOUR sample student so it's non-zero
    results, t = app.search_by_email("tanya@mycsu.edu")
    print(f"[{RUN_BY}] Found {len(results)} record(s) in {ms(t)}")

    # sort timings
    sorted_students, t2 = app.sort_by_marks()
    print(f"[{RUN_BY}] Sorted {len(sorted_students)} students by marks in {ms(t2)}")

    # stats
    stats = app.course_stats("DATA200")
    print(f"[{RUN_BY}] DATA200 stats: {stats}")
'''

with open("checkmygrade.py", "w", encoding="utf-8") as f:
    f.write(code)

print("âœ… checkmygrade.py saved successfully!")

# === CELL 2: Create the unit test file ===
tests = """
import unittest
from pathlib import Path
import shutil
import random
from checkmygrade import App, Student, Course


class TestCheckMyGrade(unittest.TestCase):
    def setUp(self):
        self.tmp = Path("test_workspace")
        if self.tmp.exists():
            shutil.rmtree(self.tmp)
        self.tmp.mkdir(parents=True)
        self.app = App(self.tmp)
        # seed with one course
        self.app.courses.add(Course("DATA200", "Data Science", "Intro to DS and Python"))

    def tearDown(self):
        shutil.rmtree(self.tmp, ignore_errors=True)

    def test_add_delete_update_student(self):
        s = Student("test1@example.com", "Test", "User", "DATA200", "A", 95)
        self.app.students.add(s)
        # update
        self.app.students.update("test1@example.com", marks=97, grade="A")
        found, _ = self.app.search_by_email("test1@example.com")
        self.assertEqual(len(found), 1)
        self.assertEqual(found[0].marks, 97.0)
        # delete
        deleted = self.app.students.delete("test1@example.com")
        self.assertTrue(deleted)
        found2, _ = self.app.search_by_email("test1@example.com")
        self.assertEqual(len(found2), 0)

    def test_sort_and_search_timing_with_1000(self):
        # add 1000 records
        for i in range(1000):
            email = f"user{i}@example.com"
            marks = random.randint(50, 100)
            self.app.students.add(Student(email, f"FN{i}", f"LN{i}", "DATA200", "A", marks))
        # search
        _, t_search = self.app.students.search(lambda s: s.email == "user500@example.com")
        # sort by marks
        _, t_sort = self.app.sort_by_marks()
        # ensure timings are recorded (floats)
        self.assertIsInstance(t_search, float)
        self.assertIsInstance(t_sort, float)

    def test_courses_add_delete_modify(self):
        self.app.courses.add(Course("CS101", "Intro CS", "Basics"))
        self.app.courses.update("CS101", course_name="Intro to CS", description="Basics Updated")
        courses = {c.course_id: c for c in self.app.courses.list()}
        self.assertIn("CS101", courses)
        self.assertEqual(courses["CS101"].course_name, "Intro to CS")
        deleted = self.app.courses.delete("CS101")
        self.assertTrue(deleted)

    def test_auth_encrypt_decrypt(self):
        # register
        self.app.auth.register("alice@example.com", "Welcome12#_", "student")
        ok = self.app.auth.login("alice@example.com", "Welcome12#_")
        self.assertTrue(ok)
        changed = self.app.auth.change_password("alice@example.com", "Welcome12#_", "NewPass123!")
        self.assertTrue(changed)
        ok2 = self.app.auth.login("alice@example.com", "NewPass123!")
        self.assertTrue(ok2)


if __name__ == "__main__":
    unittest.main()
"""

with open("test_checkmygrade.py", "w") as f:
    f.write(tests)

print("test_checkmygrade.py saved successfully!")

!python checkmygrade.py
!python -m unittest -v

!ls
!ls data

!zip -r data.zip data

!ls -lh